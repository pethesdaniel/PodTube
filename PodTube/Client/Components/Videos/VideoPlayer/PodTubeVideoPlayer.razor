@using PodTube.Shared.Models.DTO;
@inject IJSRuntime js;
@implements IAsyncDisposable;

<MudStack Spacing="0">
    <MudImage Src="@CurrentFrame" ObjectFit="ObjectFit.Contain" Fluid="true" Elevation="0" Class="video-image rounded-lg" Style="max-height: 75vh;" />
    <div style="display:flex">
        <MudToggleIconButton Toggled="@IsPaused"
                             Icon="@Icons.Material.Filled.Pause" Title="Pause"
                             ToggledIcon="@Icons.Material.Filled.PlayArrow" ToggledTitle="Play" @onclick="OnPlay" />
        <MudStack Row AlignItems="AlignItems.Center" Style="flex-grow: 1; min-width:150px">
            <MudText Typo="Typo.body2">@CurrentTimeReadable</MudText>
            <MudSlider Class="px-0 py-3" Variant="Variant.Filled" @bind-Value:get="Progress" @bind-Value:set="OnUserChangedCurrentTime"></MudSlider>
            <MudText Typo="Typo.body2">@DurationReadable</MudText>
        </MudStack>
        <MudSlider Class="px-3" Variant="Variant.Filled" Min=0 Max=1 Step=0.01 @bind-Value:get="Volume" @bind-Value:set="OnUserChangedVolume" Style="max-width:150px; flex-grow: 0">Volume</MudSlider>
    </div>
</MudStack>

@foreach (var audio in Video.Audios.Distinct()) {
    <PodTube.Client.Components.Videos.VideoPlayer.AudioPlayer.AudioPlayer Url="@audio" audioController="audioController"></PodTube.Client.Components.Videos.VideoPlayer.AudioPlayer.AudioPlayer>
}


@code {
    private VideoDto _videoDto = new();
    [Parameter]
    public VideoDto Video
    {
        get
        {
            return _videoDto;
        }
        set
        {
            if(value != _videoDto) {
                _videoDto = value;
                Audios = value.Audios.Select(a => new Audio
                    {
                        Guid = Guid.NewGuid(),
                        Url = a
                    }).ToList();
                ResetPlayback();
            }
        }
    }

    [Parameter] public string Placeholder { get; set; } = string.Empty;

    private Audio CurrentAudio = new();
    private List<Audio> Audios = new List<Audio>();
    private Dictionary<string, AudioMetadata> Metadata = new Dictionary<string, AudioMetadata>();

    private AudioController audioController = new AudioController();

    private string CurrentFrame = string.Empty;

    private double _currentTime = 0;
    private double CurrentTime {
        get {
            return _currentTime;
        }
        set {
            _currentTime = value;
            CurrentTimeReadable = $"{(value / 60).ToString("00")}:{(value % 60).ToString("00")}";
        }
    }
    private string CurrentTimeReadable = "00:00";

    private double _duration = 0;
    private double Duration {
        get {
            return _duration;
        }
        set {
            _duration = value;
            DurationReadable = $"{(value / 60).ToString("00")}:{(value % 60).ToString("00")}";
        }
    }
    private string DurationReadable = "00:00";

    private bool IsPaused = true;
    private double Progress = 0;
    private double Volume = 1;


    private ElementReference audioElement;

    protected override async Task OnInitializedAsync() {
        await base.OnInitializedAsync();
        audioController.OnTimeUpdatedEvent += OnTimeUpdated;
        audioController.OnMetadataLoadedEvent += OnMetadataLoaded;
    }

    public void OnMetadataLoaded(AudioMetadata metadata) {
        Metadata.TryAdd(metadata.Url, metadata);
        UpdatePreplay();
    }

    private void UpdatePreplay() {
        Duration = CalculateDuration();
        UpdateFrame();
        StateHasChanged();
    }


    private void OnTimeUpdated(AudioPlayerState state) {
        CurrentTime = CalculateCurrentTime(state.CurrentTime);
        Duration = CalculateDuration();
        IsPaused = state.IsPaused;
        Volume = state.Volume;
        Progress = CurrentTime / Duration * 100f;
        UpdateFrame();

        if (state.CurrentTime == state.Duration) {
            SwitchAudioToNext();
        }
        StateHasChanged();
    }

    private void SwitchAudioToNext() {
        var indx = Audios.IndexOf(CurrentAudio);
        if(indx >= Audios.Count -1) {
            ResetPlayback();
            return;
        }
        SwitchAudio(Audios[indx + 1], 0, true);
    }

    private void SwitchAudio(Audio audio, double time = 0, bool continuePlayback = false) {
        var isTrackSwitch = audio.Url != CurrentAudio.Url;
        if (isTrackSwitch) {
            audioController.PauseAudioWithUrl(CurrentAudio.Url);
            audioController.SeekAudioWithUrl(CurrentAudio.Url, 0);
        }
        CurrentAudio = audio;
        audioController.SeekAudioWithUrl(CurrentAudio.Url, time);
        if (continuePlayback) {
            audioController.PlayAudioWithUrl(CurrentAudio.Url);
        }
    }

    private void ResetPlayback() {
        CurrentAudio = Audios.FirstOrDefault() ?? new();
        audioController.SeekAudioWithUrl(CurrentAudio.Url, 0);
    }

    private void OnPlay() {
        if (IsPaused) {
            audioController.PlayAudioWithUrl(CurrentAudio.Url);
        } else {
            audioController.PauseAudioWithUrl(CurrentAudio.Url);
        }
    }

    private void UpdateFrame() {
        var frameCandidate = Video.Frames.FirstOrDefault(f => f.TimestampStart <= CurrentTime && f.TimestampEnd > CurrentTime)?.Url;
        if(frameCandidate != null) {
            CurrentFrame = CurrentFrame != frameCandidate ? frameCandidate : CurrentFrame;
        } else {
            CurrentFrame = Placeholder;
        }
    }

    private void OnUserChangedCurrentTime(double value) {
        if(Progress != value) {
            var currentTime = value / 100f * Duration;
            var coords = CalculateAudioCoordinates(currentTime);
            SwitchAudio(coords.Audio, coords.Time, !IsPaused);
            CurrentTime = currentTime;
            Progress = value;
        }
    }

    private void OnUserChangedVolume(double value) {
        if(Volume != value) {
            audioController.SetVolume(value);
            Volume = value;
        }
    }

    public async ValueTask DisposeAsync() {
        audioController.OnTimeUpdatedEvent -= OnTimeUpdated;
        audioController.OnMetadataLoadedEvent -= OnMetadataLoaded;
    }

    private double CalculateCurrentTime(double timeInCurrentUrl) {
        double acculTime = 0;
        for (int i = 0; i < Audios.IndexOf(CurrentAudio); ++i) {
            acculTime += Metadata[Audios[i].Url].Duration;
        }
        acculTime += timeInCurrentUrl;
        return acculTime;
    }

    private double CalculateDuration() {
        double acculTime = 0;
        for (int i = 0; i < Audios.Count; ++i) {
            acculTime += Metadata[Audios[i].Url].Duration;
        }
        return acculTime;
    }

    private AudioCoordinates CalculateAudioCoordinates(double time) {
        double acculTime = 0;
        double returnTime = 0;
        Audio? returnAudio = null;
        for (int i = 0; i < Audios.Count; ++i) {
            double duration = Metadata[Audios[i].Url].Duration;
            if (acculTime + duration > time) {
                returnAudio = Audios[i];
                returnTime = time - acculTime;
                break;
            } else {
                acculTime += duration;
            }
        }
        return new AudioCoordinates
            {
                Audio = returnAudio,
                Time = returnTime
            };
    }

    private class AudioCoordinates {
        public Audio Audio { get; set; }
        public double Time { get; set; }
    }

}
